<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jenkins 自动化构建（一）]]></title>
    <url>%2F2018%2F07%2F19%2Fjenkins-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介昨晚领导给我讲解了一下jenkins通过pipline方式构建jenkins结合gitlab的自动化构建镜像，大体听懂了，自己的理解，通过pipline的方式构建等同于把需要手动配置的configure的东西，全部用脚本代码来实现，也算是减少了重复配置的工作，并且能实现一些configure无法实现的情况。 Pipline什么是Pipeline，简单来说，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂发布流程。Pipeline的实现方式是一套Groovy DSL，任何发布流程都可以表述为一段Groovy脚本，并且Jenkins支持从代码库直接读取脚本，从而实现了Pipeline as Code的理念。Pipeline脚本是用Groovy写的，有的复杂的配置可以通过生成器直接生产代码，复制到代码结构中。pipline脚本方式有两种生成如下图具体通过生成器产生代码方法，其实就是跟手动配置configure一样 Declarative Pipeline语法结构模式Declarative Pipeline 语法链接123456789101112131415161718192021pipeline &#123; agent any ####指定你跑的jenkins跑在哪个节点上，如果配置了分布式构建，这里就可以指定 parameters &#123; ****** #####需要的参数 对应congfigure里面的parameters &#125; options &#123; ****** ####选项 &#125; environment &#123; ****** ####环境变量 这里面的env 只能在steps调用 测试过triggers调用取不到 &#125; triggers &#123; gitlab( ### gitlab触发器配置 *******） &#125; stages &#123; ###这里就是主要的步骤 stage('git source') &#123; ### 可以写多个stages steps &#123; ### 每个stages可以多个steps **** &#125; &#125; 举个荔枝12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485pipeline &#123; agent &#123; label 'jenkins-slave' &#125; parameters &#123; string(name: 'gitTagName', defaultValue: '', description: '可空', trim: true) &#125; options &#123; disableConcurrentBuilds() buildDiscarder logRotator(daysToKeepStr: '30', numToKeepStr: '30') &#125; environment &#123; GRADLE_USER_HOME = "$&#123;WORKSPACE&#125;" ###指定下 gradle 编译的家目录 &#125; triggers &#123; gitlab( triggerOnPush: true, triggerOnMergeRequest: true, triggerOpenMergeRequestOnPush: "never", triggerOnNoteRequest: true, noteRegex: "Jenkins please retry a build", skipWorkInProgressMergeRequest: true, ciSkip: true, setBuildDescription: true, addNoteOnMergeRequest: true, addCiMessage: true, addVoteOnMergeRequest: true, acceptMergeRequestOnSuccess: false, branchFilterType: "RegexBasedFilter", ##分支过滤 targetBranchRegex: '(.*develop.*|.*\\d+(\\.\\d+)&#123;0,3&#125;)',##过滤的正则表达式 cancelPendingBuildsOnUpdate: false, secretToken: "45ed456533423245f4c8dbf9c669") ####随便撸一串长字符串，这段字符串需要跟GitLab webhook URL一起填到 gitlab setting--integration中 &#125; stages &#123; stage('git source') &#123; steps &#123; script &#123; if (env.gitlabActionType == 'TAG_PUSH') &#123; env.gitTagName = env.gitlabBranch.replaceAll('refs/tags/', '') &#125; env.gitBranchName = '*/develop' if (env.gitTagName != '') &#123; env.gitBranchName = "refs/tags/$&#123;env.gitTagName&#125;" currentBuild.displayName = "#$&#123;BUILD_NUMBER&#125; ($&#123;env.gitTagName&#125;)" &#125;else &#123; currentBuild.displayName = "#$&#123;BUILD_NUMBER&#125; (develop)" &#125; &#125; checkout([$class: 'GitSCM', branches: [[name: "$&#123;gitBranchName&#125;"]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'SubmoduleOption', disableSubmodules: false, parentCredentials: false, recursiveSubmodules: true, reference: '', trackingSubmodules: true]], submoduleCfg: [], userRemoteConfigs: [[url: '*************$&#123;JOB_BASE_NAME&#125;.git']]]) ####******指定自己的代码库 &#125; &#125; stage('java build') &#123; steps &#123; retry(3) &#123; sh 'gradle clean --refresh-dependencies publish build -x test' &#125; &#125; &#125; stage('docker build') &#123; steps &#123; withCredentials([string(credentialsId: 'HarborUser', variable: 'harborUser'), string(credentialsId: 'HarborPasswd', variable: 'harborPwd')]) &#123; retry(3) &#123; sh ''' docker login -u $&#123;harborUser&#125; -p $&#123;harborPwd&#125; harbor.abc.com ###*****你的docker镜像仓库 if [ -z $gitTagName ] ; then docker build -t harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125; . docker push harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125;:latest else docker build -t harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125;:$&#123;gitTagName&#125; . docker push harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125;:$&#123;gitTagName&#125; fi ''' &#125; &#125; &#125; &#125; &#125; post &#123; failure &#123; emailext body: '$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS: Check console output at $BUILD_URL to view the results.', recipientProviders: [requestor(), brokenBuildSuspects()], subject: '$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!' &#125; &#125;&#125; jenkins中配置采用pipeline script from SCM方式，在pipline选项中选择。pipeline script from SCM：需要配置SCM代码存储Git地址或SVN地址，指定script文件Jenkinsfile所在路径，每次构建job会自动去指定的目录执行script文件具体配置查看官方文档 现在阶段只是配置了构建镜像，并没有集成到部署，学习中待补。。。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_my_site]]></title>
    <url>%2F2018%2F07%2F17%2Ftest-my-site%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
