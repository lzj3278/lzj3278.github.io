<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ceph分布式文件系统搭建与使用]]></title>
    <url>%2F2018%2F07%2F20%2Fceph%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[ceph简介Ceph is a distributed object, block, and file storage platform. 也就是说，使用Ceph系统我们可以提供对象存储、块设备存储和文件系统服务，Ceph底层提供了分布式的RADOS存储，用与支撑上层的librados和RGW、RBD、CephFS等服务。Ceph实现了非常底层的object storage，是纯粹的SDS，并且支持通用的ZFS、BtrFS、Ext4等文件系统，能轻易得Scale，没有单点故障。 所有 Ceph 存储集群的部署都始于部署一个个 Ceph 节点、网络和 Ceph 存储集群。 Ceph 存储集群至少需要一个 Ceph Monitor ，一个Ceph Manager，一个 OSD 守护进程。而运行 Ceph 文件系统客户端时，则必须要有元数据服务器（ Metadata Server ）。Monitors: Ceph Monitor维护着展示集群状态的各种图表，包括监视器map、管理map、 OSD map、归置组（ PG ）map、和 CRUSH map。这些映射是Ceph守护进程相互协调所需的关键集群状态。Monitors还负责管理守护进程和客户端之间的身份验证。通常需要至少三台显示器才能实现冗余和高可用性。 Managers: Ceph Manager守护进程（ceph-mgr）负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager守护程序还托管基于python的插件来管理和公开Ceph集群信息，包括基于Web的仪表板和REST API。高可用性通常需要至少两个managers节点。 Ceph OSD：Ceph OSD（对象存储守护进程，ceph-osd）存储数据，处理数据复制，恢复，重新平衡，并通过检查其他Ceph OSD守护进程的心跳向Ceph Manager和Monitors提供一些监视信息。通常需要至少3个Ceph OSD来实现冗余和高可用性。 MDSs：Ceph元数据服务器（MDS，ceph-mds）代表Ceph文件系统存储元数据（即，Ceph块设备和Ceph对象存储器不使用MDS）。 Ceph元数据服务器允许POSIX文件系统用户执行基本命令（如ls，find等），而不会给Ceph存储集群带来巨大的负担。 Ceph将数据作为对象存储在逻辑存储池中。使用CRUSH算法，Ceph计算哪个放置组应包含该对象，并进一步计算哪个Ceph OSD守护程序应存储放置组。 CRUSH算法使Ceph存储集群能够动态扩展，重新平衡和恢复。 ceph 存储集群搭建ceph集群架构 安装前准备1 管理节点安装ceph-deploy1234567891011121314sudo yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmcat &lt;&lt; EOM &gt; /etc/yum.repos.d/ceph.repo[ceph-noarch]name=Ceph noarch packagesbaseurl=https://download.ceph.com/rpm-luminous/el7/noarchenabled=1gpgcheck=1type=rpm-mdgpgkey=https://download.ceph.com/keys/release.ascEOMsudo yum updatesudo yum install ceph-deploy 2 配置预装环境123456789101112131 安装 ntp sudo yum install ntp2 创建一个deploy用户，使用ansible用户。useradd ansiblepasswd ansibleecho "ansible ALL = (root) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/ansible3 配置免密登录su - ansiblessh-keygenssh-copy-id ceph-01 ceph-02 ceph-034 关闭防火墙，关闭selinuxsystemctl stop firewallsudo setenforce 0 部署ceph 存储集群都是在admin-node 执行下面操作 1 创建一个ceph-admin文件夹12su - ansiblemkdir ceph-admin 2 初始化安装镜像源12export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/rpm-luminous/el7export CEPH_DEPLOY_GPG_URL=http://mirrors.163.com/ceph/keys/release.asc 3 创建mon节点1ceph-deploy new ceph-01 ceph-02 ceph-03 4 配置 ceph.conf配置文件添加如下配置：123456789osd pool default size = 3osd pool default min size = 2osd pool default pg num = 32osd pool default pgp num = 32rgw_thread_pool_size = 512 objecter_inflight_ops = 4096 objecter_inflight_op_bytes = 1048576000 osd_op_num_shards = 16 osd_client_message_size_cap = 1073741824 5 安装 Ceph packages1ceph-deploy install ceph-01 ceph-02 ceph-03 6 初始化 mon节点，生成key1ceph-deploy mon create-initial 7 复制key ceph.conf到各节点1ceph-deploy admin ceph-01 ceph-02 ceph-03 8 创建管理节点1ceph-deploy mgr create ceph-01 ceph-02 ceph-03 9 创建添加OSDs123456ceph-deploy osd create --data vgdata/dataceph1 ceph-01ceph-deploy osd create --data vgdata/dataceph2 ceph-01ceph-deploy osd create --data vgdata/dataceph1 ceph-02ceph-deploy osd create --data vgdata/dataceph2 ceph-02ceph-deploy osd create --data vgdata/dataceph1 ceph-03ceph-deploy osd create --data vgdata/dataceph2 ceph-03 10 检查状态1ssh ceph-01 sudo ceph -s 11 激活dashboard prometheus12ceph mgr module enable dashboardceph mgr module enable prometheus 创建对象存储及对象存储操作1 创建对象储存服务1ceph-deploy rgw create ceph-01 ceph-02 ceph-03 2 创建对象存储admin用户，保存user跟keys123456789101112131415161718192021222324 radosgw-admin user create --uid=rgw_admin --display-name="rgw_admin"lay-name="rgw_admin"&#123; "user_id": "rgw_admin", "display_name": "rgw_admin", "email": "", "suspended": 0, "max_buckets": 1000, "auid": 0, "subusers": [], "keys": [ &#123; "user": "rgw_admin", "access_key": "ETD21OM**********3R7", "secret_key": "****FvXC**********0LBWIjO****bKI" &#125; ], "swift_keys": [], "caps": [], "op_mask": "read, write, delete", "default_placement": "",......&#125; 3 安装配置s3cmd12345yum install s3cmds3cmd --configure 配置keys host_base修改 root/.s3cfghost_base = 192.168.1.4:3480host_bucket = 192.168.1.4:3480/%(bucket) 4 创建桶1s3cmd mb s3://store-test 5 操作桶测试1s3cmd put a.jpg s3://store_test --acl-public 6 网页验证图片显示1https://***********.com/a.jpg]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux环境及VIM配置]]></title>
    <url>%2F2018%2F07%2F20%2FVIM%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我自己的vim配置文件针对python向的vimgithub地址：vim 一键安装脚本安装脚本写的比较简陋 只是按照安装步骤顺序的流水线，没有做错误应对脚本中注释了 youcompleteme 插件的安装，这插件太大用不熟,插件url地址如果过期请自行更正。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 #! /bin/bash####################Created Time: 2016-11-01 14:38:41##################install_vim = trueCURRENT_DIR=`pwd`echo "step1: backing up current vim config"today=`date +%Y%m%d`if $install_vim; then for i in $HOME/.vim $HOME/.vimrc $HOME/.gvimrc $HOME/.vimrc.bundles; do [ -e $i ] &amp;&amp; [ ! -L $i ] &amp;&amp; mv $i $i.$today; done for i in $HOME/.vim $HOME/.vimrc $HOME/.gvimrc $HOME/.vimrc.bundles; do [ -L $i ] &amp;&amp; unlink $i ; donefiecho "step2: setting up dir,copy vim inside"mkdir -p ~/.vim/bundlemkdir -p ~/.vim/ftpluginmkdir -p ~/.vim/colorsmkdir -p ~/.vim/template/#yum install python -y #yum install cmake -y #yum install -y gcc gcc-c++pip install autopep8 jedi &gt; /dev/null 2&gt;&amp;1cp template/* ~/.vim/template/cp .vimrc ~/cd ~/.vim/bundlegit clone https://github.com/VundleVim/Vundle.vim.gitcd ~/.vim/colorswget -O wombat256mod.vim http://www.vim.org/scripts/download_script.php?src_id=13400wget -O ~/.vim/ftplugin/python_editing.vim http://www.vim.org/scripts/download_script.php?src_id=5492echo "Step3: update/install plugins using Vundle"system_shell=$SHELLexport SHELL="/bin/sh"vim -u ~/.vimrc +PluginInstall! +qallexport SHELL=$system_shell#echo "Step4: compile YouCompleteMe"#echo "It will take a long time, just be patient!"#echo "If error,you need to compile it yourself"#echo "cd ~/.vim/bundle/YouCompleteMe/ &amp;&amp; python install.py "#cd ~/.vim/bundle/YouCompleteMe/#git submodule update --init --recursive#python install.pyecho "Install Done" 12chmod 755 install.sh ./install.sh 手动详解安装创建文件夹：创建一个存插件的文件夹1234cd ~mkdir .vimmkdir -p ~/.vim/bundlemkdir -p ~/.vim/ftplugin 安装python包：12pip install autopep8 pip install jedi 插件管理器安装:1234cd ~/.vim/bundlegit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vimvim ：PluginInstall 来安装插件 主题插件安装12mkdir -p ~/.vim/colors &amp;&amp; cd ~/.vim/colors wget -O wombat256mod.vim http://www.vim.org/scripts/download_script.php?src_id=13400 python 折叠12mkdir -p ~/.vim/ftplugin wget -O ~/.vim/ftplugin/python_editing.vim http://www.vim.org/scripts/download_script.php?src_id=5492 文件头的添加12mkdir -p ~/.vim/template/ cp template/* ~/.vim/template/ 用法说明（快捷键）功能键F按键映射 F2 打开文件树F3 开启格式化粘贴 (用于在外部粘贴大段代码块，复制进来，要不会无限缩进）F4 一键注释F5 一键执行F6 快速开启/关闭行号F8 自动pep8 格式化 插件列表kien/ctrlp.vim 我的leader键映射的是 “,”按 (，f) 打开最近打开的文件，非常好用按 (，p) 文件所在文件夹列表文件ctrl + v 竖排打开文件ctrl + x 上下打开文件ctrl + t tab中打开文件 tacahiroy/ctrlp-funky (，fu) 进入当前文件的函数列表搜索 (，fU) 搜索当前光标下单词对应的函数 klen/python-mode r 一键执行 Valloric/YouCompleteMe d : 跳转到函数定义 tpope/vim-surround “替换: cs”‘ “”Hello world!” -&gt; ‘Hello world!’ “替换-标签(t=tag): cst”“abc -&gt; “abc”“删除: ds”“Hello world!” -&gt; Hello world!“添加(ys=you surround): ysiw” “Hello -&gt; “Hello”“添加-整行: yss” “Hello world -&gt; “Hello world” mattn/emmet-vim 插入 html:5 ====》ctrl+y+,生产html文件插件用法教程 NERD Tree 通过hjkl来移动光标o打开关闭文件或目录，如果想打开文件，必须光标移动到文件名t在标签页中打开s和i可以水平或纵向分割窗口打开文件p到上层目录P到根目录K到同目录第一个节点P到同目录最后一个节点 我的bash配置其实就是换成 oh-my-zshoh-my-zsh github 安装1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 主题配置我用的是 ys 感觉顺眼 END]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins 自动化构建（一）]]></title>
    <url>%2F2018%2F07%2F19%2Fjenkins-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介昨晚领导给我讲解了一下jenkins通过pipline方式构建jenkins结合gitlab的自动化构建镜像，大体听懂了，自己的理解，通过pipline的方式构建等同于把需要手动配置的configure的东西，全部用脚本代码来实现，也算是减少了重复配置的工作，并且能实现一些configure无法实现的情况。 Pipline什么是Pipeline，简单来说，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂发布流程。Pipeline的实现方式是一套Groovy DSL，任何发布流程都可以表述为一段Groovy脚本，并且Jenkins支持从代码库直接读取脚本，从而实现了Pipeline as Code的理念。Pipeline脚本是用Groovy写的，有的复杂的配置可以通过生成器直接生产代码，复制到代码结构中。pipline脚本方式有两种生成如下图具体通过生成器产生代码方法，其实就是跟手动配置configure一样 Declarative Pipeline语法结构模式Declarative Pipeline 语法链接123456789101112131415161718192021pipeline &#123; agent any ####指定你跑的jenkins跑在哪个节点上，如果配置了分布式构建，这里就可以指定 parameters &#123; ****** #####需要的参数 对应congfigure里面的parameters &#125; options &#123; ****** ####选项 &#125; environment &#123; ****** ####环境变量 这里面的env 只能在steps调用 测试过triggers调用取不到 &#125; triggers &#123; gitlab( ### gitlab触发器配置 *******） &#125; stages &#123; ###这里就是主要的步骤 stage('git source') &#123; ### 可以写多个stages steps &#123; ### 每个stages可以多个steps **** &#125; &#125; Jenkinsfile12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485pipeline &#123; agent &#123; label 'jenkins-slave' &#125; parameters &#123; string(name: 'gitTagName', defaultValue: '', description: '可空', trim: true) &#125; options &#123; disableConcurrentBuilds() buildDiscarder logRotator(daysToKeepStr: '30', numToKeepStr: '30') &#125; environment &#123; GRADLE_USER_HOME = "$&#123;WORKSPACE&#125;" ###指定下 gradle 编译的家目录 &#125; triggers &#123; gitlab( triggerOnPush: true, triggerOnMergeRequest: true, triggerOpenMergeRequestOnPush: "never", triggerOnNoteRequest: true, noteRegex: "Jenkins please retry a build", skipWorkInProgressMergeRequest: true, ciSkip: true, setBuildDescription: true, addNoteOnMergeRequest: true, addCiMessage: true, addVoteOnMergeRequest: true, acceptMergeRequestOnSuccess: false, branchFilterType: "RegexBasedFilter", ##分支过滤 targetBranchRegex: '(.*develop.*|.*\\d+(\\.\\d+)&#123;0,3&#125;)',##过滤的正则表达式 cancelPendingBuildsOnUpdate: false, secretToken: "45ed456533423245f4c8dbf9c669") ####随便撸一串长字符串，这段字符串需要跟GitLab webhook URL一起填到 gitlab setting--integration中 &#125; stages &#123; stage('git source') &#123; steps &#123; script &#123; if (env.gitlabActionType == 'TAG_PUSH') &#123; env.gitTagName = env.gitlabBranch.replaceAll('refs/tags/', '') &#125; env.gitBranchName = '*/develop' if (env.gitTagName != '') &#123; env.gitBranchName = "refs/tags/$&#123;env.gitTagName&#125;" currentBuild.displayName = "#$&#123;BUILD_NUMBER&#125; ($&#123;env.gitTagName&#125;)" &#125;else &#123; currentBuild.displayName = "#$&#123;BUILD_NUMBER&#125; (develop)" &#125; &#125; checkout([$class: 'GitSCM', branches: [[name: "$&#123;gitBranchName&#125;"]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'SubmoduleOption', disableSubmodules: false, parentCredentials: false, recursiveSubmodules: true, reference: '', trackingSubmodules: true]], submoduleCfg: [], userRemoteConfigs: [[url: '*************$&#123;JOB_BASE_NAME&#125;.git']]]) ####******指定自己的代码库 &#125; &#125; stage('java build') &#123; steps &#123; retry(3) &#123; sh 'gradle clean --refresh-dependencies publish build -x test' &#125; &#125; &#125; stage('docker build') &#123; steps &#123; withCredentials([string(credentialsId: 'HarborUser', variable: 'harborUser'), string(credentialsId: 'HarborPasswd', variable: 'harborPwd')]) &#123; retry(3) &#123; sh ''' docker login -u $&#123;harborUser&#125; -p $&#123;harborPwd&#125; harbor.abc.com ###*****你的docker镜像仓库 if [ -z $gitTagName ] ; then docker build -t harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125; . docker push harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125;:latest else docker build -t harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125;:$&#123;gitTagName&#125; . docker push harbor.abc.com/test/$&#123;JOB_BASE_NAME&#125;:$&#123;gitTagName&#125; fi ''' &#125; &#125; &#125; &#125; &#125; post &#123; failure &#123; emailext body: '$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS: Check console output at $BUILD_URL to view the results.', recipientProviders: [requestor(), brokenBuildSuspects()], subject: '$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!' &#125; &#125;&#125; jenkins配置采用pipeline script from SCM方式，在pipline选项中选择。pipeline script from SCM：需要配置SCM代码存储Git地址或SVN地址，指定script文件Jenkinsfile所在路径，每次构建job会自动去指定的目录执行script文件。具体配置查看官方文档 现在阶段只是配置了构建镜像，并没有集成到部署，学习中待补。。。参考文档jenkinsci/gitlab-plugin jenkins 官方文档 END]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_my_site]]></title>
    <url>%2F2018%2F07%2F17%2Ftest-my-site%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
